{"version":3,"sources":["Core/Utils.ts","Core/Piano.ts","Containers/piano/Key.tsx","Containers/PianoKyes.tsx","Core/piano/actions.ts","Components/Button.tsx","App/App.tsx","serviceWorker.ts","Core/piano/reducer.ts","Core/Store.ts","index.tsx"],"names":["Utils","start","this","sacleWhite","map","v","list","forEach","push","sacleBlack","includes","end","makeScaleAll","i","getKeyTones","newList","tone","isValue","startTone","key","result","obj","a","w","s","e","d","f","t","g","y","h","u","j","k","hasOwnProperty","target","targetMinusShap","replace","parentTone","document","querySelector","getBoundingClientRect","x","positionStart","synth","Tone","toDestination","Piano","triggerAttackRelease","note","duration","time","velocity","Key","isActive","onToneClick","useState","blackPosition","setBlackPosition","useEffect","getBlackPosition","className","trigger","style","left","onMouseDown","data-tone","PianoKyes","tones","useSelector","state","piano","dispatch","useDispatch","pressKey","type","payload","pianoTrigger","setTimeout","pianoRelese","handleToneClick","onKeyPress","event","value","getKeyToTone","index","findIndex","toneObj","tabIndex","item","Button","text","onClick","App","getScale5","now","Boolean","window","location","hostname","match","initState","initTones","pianoReducer","actions","newTones","rootReducer","combineReducers","store","createStore","applyMiddleware","thunk","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"qOAGaA,EAAb,uGAImBC,GACf,OAAOC,KAAKC,WAAWC,KAAI,SAACC,GAAD,OAAQA,EAAIJ,OAL3C,mCAOsBA,GAA4B,IAAD,OACzCK,EAAmB,GAOvB,OANAJ,KAAKC,WAAWI,SAAQ,SAACF,GACvBC,EAAKE,KAAMH,EAAIJ,GACX,EAAKQ,WAAWC,SAASL,IAC3BC,EAAKE,KAAMH,EAAI,IAAMJ,MAGlBK,IAfX,kCAkBqBL,GAA6C,IAA9BU,EAA6B,uDAAf,EAC9C,GAAY,IAARA,EACF,OAAOT,KAAKU,aAAaX,GAI3B,IADA,IAAIK,EAAmB,GACdO,EAAIZ,EAAOY,GAAKF,EAAKE,IAE5BP,EAAI,sBAAOA,GAAP,YAAgBJ,KAAKU,aAAaC,KAExC,OAAOP,IA5BX,gCA+BmBL,GAAkD,IAAnCU,EAAkC,uDAApB,EACtCL,EAAON,EAAMc,YAAYb,EAAOU,GAEhCI,EAA2B,GAQjC,OAPAT,EAAKC,SAAQ,SAACF,GACZU,EAAQP,KAAK,CACXQ,KAAMX,EACNY,SAAS,OAINF,IA1CX,gCA6CmBG,GAaf,MAZsB,CACpB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QAvDN,mCA6DsBC,GAClB,IAAIC,EAIEC,EAAiB,CACrBC,EAAG,KACHC,EAAG,MACHC,EAAG,KACHC,EAAG,MACHC,EAAG,KACHC,EAAG,KACHC,EAAG,MACHC,EAAG,KACHC,EAAG,MACHC,EAAG,KACHC,EAAG,MACHC,EAAG,KACHpB,EAAG,MACHqB,EAAG,MAML,OAHIb,EAAIc,eAAehB,KACrBC,EAASC,EAAIF,IAERC,IAtFX,uCA0F0BgB,GACtB,IAAKA,EAAO1B,SAAS,KACnB,OAAO,EAGT,IAAM2B,EAAkBD,EAAOE,QAAQ,IAAK,IACtCC,EAAaC,SAASC,cAAT,qBAAqCJ,EAArC,MAInB,QAFa,OAAVE,QAAU,IAAVA,OAAA,EAAAA,EAAYG,wBAAwBC,IAAK,GAAKzC,KAAK0C,kBAlG1D,KAAa5C,EACJG,WAAa,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KADxCH,EAEJS,WAAa,CAAC,IAAK,IAAK,IAAK,IAAK,KAF9BT,EAyFJ4C,cAAgB,G,2BCzFnBC,GAAQ,IAAIC,KAAaC,gBAElBC,EAAb,qGACiBhC,GACb6B,EAAMI,qBAAqBjC,EAAM,QAFrC,2CAMIkC,EACAC,EACAC,EACAC,QATJ,KCqCeC,EA9BH,SAAC,GAA6C,IAA3CtC,EAA0C,EAA1CA,KAAMuC,EAAoC,EAApCA,SAAUC,EAA0B,EAA1BA,YAA0B,EACbC,qBADa,mBAChDC,EADgD,KACjCC,EADiC,KAGvDC,qBAAU,WACRD,EAAiB3D,EAAM6D,iBAAiB7C,MACvC,CAACA,IAEJ,IAAM8C,EAAS,cAAU9C,EAAKN,SAAS,KAAO,QAAU,GAAzC,YACb6C,EAAW,SAAW,IAUxB,OAPAK,qBAAU,WACJL,GACFP,EAAMe,QAAQ/C,KAGf,CAACuC,IAGF,yBACEO,UAAWA,EACXE,MAAO,CAAEC,KAAMP,GACfQ,YAAa,kBAAMV,EAAYxC,IAC/BmD,YAAWnD,GAEX,0BAAM8C,UAAU,aAAa9C,KC0BpBoD,EArDG,SAAC,GAAgB,eACjC,IAAMC,EAAQC,aAAY,SAACC,GAAD,OAAsBA,EAAMC,MAAMH,SACtDI,EAAWC,cAEXC,EAAW,SAAC3D,GAChByD,ECVwB,SAACzD,GAC3B,MAAO,CACL4D,KALyB,gBAMzBC,QAAS7D,GDOA8D,CAAa9D,IAEtB+D,YAAW,WACTN,ECNqB,SAACzD,GAC1B,MAAO,CACL4D,KAXyB,gBAYzBC,QAAS7D,GDGEgE,CAAYhE,MACpB,MAgBCiE,EAAkB,SAACjE,GACvB2D,EAAS3D,IAGX,OACE,yBACE8C,UAAU,aACVoB,WAnBkB,SAACC,GACrB,IAAMhE,EAAMgE,EAAMhE,IACdiE,EAAQpF,EAAMqF,aAAalE,GAC/B,GAAKiE,EAAL,CACA,IAAME,EAAK,OAAGjB,QAAH,IAAGA,OAAH,EAAGA,EAAOkB,WAAU,SAAClF,GAC9B,OAAOA,EAAEW,OAASoE,KAEdI,EAAUnB,EAAMiB,GACjBE,GACLb,EAASa,EAAQxE,QAYfyE,SAAU,GAEV,yBAAK3B,UAAU,sBACZO,GACCA,EAAMjE,KAAI,SAACsF,GACT,OACE,kBAAC,EAAD,CACEvE,IAAKuE,EAAK1E,KACVA,KAAM0E,EAAK1E,KACXwC,YAAayB,EACb1B,SAAUmC,EAAKzE,gBExChB0E,EARA,SAAC,GAA+B,IAA7BC,EAA4B,EAA5BA,KAAMC,EAAsB,EAAtBA,QACtB,OACE,4BAAQ/B,UAAS,OAAU+B,QAASA,GACjCD,ICHD/C,GAAQ,IAAIC,KAAaC,gBAkBhB+C,MAhBf,WAME,OACE,yBAAKhC,UAAU,OACb,4BAAQA,UAAU,cAChB,kBAAC,EAAD,MACA,kBAAC,EAAD,CAAQ8B,KAAK,eAAKC,QATJ,WAClB,IAAMvF,EAAON,EAAM+F,UAAU,MACvBC,EAAMlD,MACZxC,EAAKC,SAAQ,SAACF,EAAGQ,GAAJ,OAAUgC,EAAMI,qBAAqB5C,EAAG,KAAM2F,EAAU,GAAJnF,Y,MCAjDoF,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,WCTAC,EAAoB,CACxBjC,MAFWrE,EAAMuG,UAAU,EAAG,IA+BjBC,EA1BM,WAAuD,IAAtDjC,EAAqD,uDAArC+B,EAAWG,EAA0B,uCACzE,OAAQA,EAAQ7B,MACd,IJbyB,gBIcvB,IAAM5D,EAAOyF,EAAQ5B,QACfS,EAAQf,EAAMF,MAAMkB,WAAU,SAAClF,GAAD,OAAOA,EAAEW,OAASA,KAChD0F,EAAQ,YAAOnC,EAAMF,OAE3B,OADAqC,EAASpB,GAAOrE,SAAU,EACnB,2BACFsD,GADL,IAEEF,MAAM,YAAKqC,KAEf,IJrByB,gBIsBvB,IAAM1F,EAAOyF,EAAQ5B,QACfS,EAAQf,EAAMF,MAAMkB,WAAU,SAAClF,GAAD,OAAOA,EAAEW,OAASA,KAChD0F,EAAQ,YAAOnC,EAAMF,OAE3B,OADAqC,EAASpB,GAAOrE,SAAU,EACnB,2BACFsD,GADL,IAEEF,MAAM,YAAKqC,KAGf,QACE,OAAOnC,I,gBChCPoC,EAAcC,YAAgB,CAAEpC,MAAOgC,IAM9BK,EAFPC,YAAYH,EAAaI,YAAgBC,MCCjDC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,IAAD,CAAUN,MAAOA,GACf,kBAAC,EAAD,QAGJrE,SAAS4E,eAAe,SH6HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.d305cd58.chunk.js","sourcesContent":["import { IKeyTone } from \"Interface/IKeyTone\";\nimport { IToneKeyboard } from \"Interface/IToneKeyboard\";\n\nexport class Utils {\n  static sacleWhite = [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"];\n  static sacleBlack = [\"C\", \"D\", \"F\", \"G\", \"A\"];\n\n  static makeScale(start: number): IKeyTone[] {\n    return this.sacleWhite.map((v) => (v + start) as IKeyTone);\n  }\n  static makeScaleAll(start: number): IKeyTone[] {\n    let list: IKeyTone[] = [];\n    this.sacleWhite.forEach((v) => {\n      list.push((v + start) as IKeyTone);\n      if (this.sacleBlack.includes(v)) {\n        list.push((v + \"#\" + start) as IKeyTone);\n      }\n    });\n    return list;\n  }\n\n  static getKeyTones(start: number, end: number = 0): IKeyTone[] {\n    if (end === 0) {\n      return this.makeScaleAll(start);\n    }\n\n    let list: IKeyTone[] = [];\n    for (let i = start; i <= end; i++) {\n      // list.push(\"C1\");\n      list = [...list, ...this.makeScaleAll(i)];\n    }\n    return list;\n  }\n\n  static initTones(start: number, end: number = 0): IToneKeyboard[] {\n    const list = Utils.getKeyTones(start, end);\n\n    const newList: IToneKeyboard[] = [];\n    list.forEach((v) => {\n      newList.push({\n        tone: v,\n        isValue: false,\n      });\n    });\n\n    return newList;\n  }\n\n  static getScale5(startTone: IKeyTone): IKeyTone[] {\n    const a: IKeyTone[] = [\n      \"C3\",\n      \"D3\",\n      \"E3\",\n      \"F3\",\n      \"G3\",\n      \"F3\",\n      \"E3\",\n      \"D3\",\n      \"C3\",\n    ];\n\n    return a;\n  }\n\n  static getKeyToTone(key: string): IKeyTone | undefined {\n    let result: IKeyTone | undefined;\n    interface IKeyValue {\n      [key: string]: IKeyTone;\n    }\n    const obj: IKeyValue = {\n      a: \"C3\" as IKeyTone,\n      w: \"C#3\" as IKeyTone,\n      s: \"D3\" as IKeyTone,\n      e: \"D#3\" as IKeyTone,\n      d: \"E3\" as IKeyTone,\n      f: \"F3\" as IKeyTone,\n      t: \"F#3\" as IKeyTone,\n      g: \"G3\" as IKeyTone,\n      y: \"G#3\" as IKeyTone,\n      h: \"A3\" as IKeyTone,\n      u: \"A#3\" as IKeyTone,\n      j: \"B3\" as IKeyTone,\n      i: \"B#3\" as IKeyTone,\n      k: \"C4\" as IKeyTone,\n    };\n\n    if (obj.hasOwnProperty(key)) {\n      result = obj[key];\n    }\n    return result;\n  }\n\n  static positionStart = 30;\n  static getBlackPosition(target: IKeyTone): number {\n    if (!target.includes(\"#\")) {\n      return 0;\n    }\n\n    const targetMinusShap = target.replace(\"#\", \"\");\n    const parentTone = document.querySelector(`[data-tone=${targetMinusShap}]`);\n    const parnetToneX =\n      (parentTone?.getBoundingClientRect().x || 0) + this.positionStart;\n\n    return parnetToneX;\n  }\n}\n","import { IKeyTone } from \"Interface/IKeyTone\";\nimport * as Tone from \"tone\";\nimport { Frequency, NormalRange, Time } from \"tone/build/esm/core/type/Units\";\nconst synth = new Tone.Synth().toDestination();\n\nexport class Piano {\n  static trigger(tone: IKeyTone) {\n    synth.triggerAttackRelease(tone, \"8n\");\n  }\n\n  static triggerAttackRelease(\n    note: Frequency,\n    duration: Time,\n    time?: Time,\n    velocity?: NormalRange\n  ) {}\n}\n","import React, { useEffect, useState } from \"react\";\nimport { IKeyTone } from \"Interface/IKeyTone\";\nimport { Utils } from \"Core/Utils\";\nimport { Piano } from \"Core/Piano\";\n\n// const now = Tone.now();\n\ninterface IProps {\n  tone: IKeyTone;\n  isActive: boolean;\n  onToneClick: (tone: IKeyTone) => void;\n}\nconst Key = ({ tone, isActive, onToneClick }: IProps) => {\n  const [blackPosition, setBlackPosition] = useState<number>();\n\n  useEffect(() => {\n    setBlackPosition(Utils.getBlackPosition(tone));\n  }, [tone]);\n\n  const className = `key ${tone.includes(\"#\") ? \"black\" : \"\"} ${\n    isActive ? \"active\" : \"\"\n  }`;\n\n  useEffect(() => {\n    if (isActive) {\n      Piano.trigger(tone);\n    } else {\n    }\n  }, [isActive]);\n\n  return (\n    <div\n      className={className}\n      style={{ left: blackPosition }}\n      onMouseDown={() => onToneClick(tone)}\n      data-tone={tone}\n    >\n      <span className=\"key__name\">{tone}</span>\n    </div>\n  );\n};\n\nexport default Key;\n","import { pianoRelese, pianoTrigger } from \"Core/piano/actions\";\nimport { RootState } from \"Core/Store\";\nimport { Utils } from \"Core/Utils\";\nimport { IKeyTone } from \"Interface/IKeyTone\";\nimport { IToneKeyboard } from \"Interface/IToneKeyboard\";\nimport React, { useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Key from \"./piano/Key\";\n\ninterface IProps {}\nconst PianoKyes = ({}: IProps) => {\n  const tones = useSelector((state: RootState) => state.piano.tones);\n  const dispatch = useDispatch();\n\n  const pressKey = (tone: IKeyTone) => {\n    dispatch(pianoTrigger(tone));\n\n    setTimeout(() => {\n      dispatch(pianoRelese(tone));\n    }, 500);\n  };\n\n  // 키보드\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    const key = event.key;\n    let value = Utils.getKeyToTone(key);\n    if (!value) return;\n    const index = tones?.findIndex((v) => {\n      return v.tone === value;\n    });\n    const toneObj = tones[index];\n    if (!toneObj) return;\n    pressKey(toneObj.tone);\n  };\n\n  const handleToneClick = (tone: IKeyTone) => {\n    pressKey(tone);\n  };\n\n  return (\n    <div\n      className=\"piano-kyes\"\n      onKeyPress={handleKeyDown}\n      // onKeyUp={handleKeyUp}\n      tabIndex={0}\n    >\n      <div className=\"piano-kyes__whites\">\n        {tones &&\n          tones.map((item) => {\n            return (\n              <Key\n                key={item.tone}\n                tone={item.tone}\n                onToneClick={handleToneClick}\n                isActive={item.isValue}\n              />\n            );\n          })}\n      </div>\n    </div>\n  );\n};\n\nexport default PianoKyes;\n","import { IKeyTone } from \"Interface/IKeyTone\";\n\nexport const PIANO_TRIGGER = \"PIANO_TRIGGER\" as const;\nexport const PIANO_RELEASE = \"PIANO_RELEASE\" as const;\n\nexport const pianoTrigger = (tone: IKeyTone) => {\n  return {\n    type: PIANO_TRIGGER,\n    payload: tone,\n  };\n};\n\nexport const pianoRelese = (tone: IKeyTone) => {\n  return {\n    type: PIANO_RELEASE,\n    payload: tone,\n  };\n};\n\nexport type PianoActions =\n  | ReturnType<typeof pianoTrigger>\n  | ReturnType<typeof pianoRelese>;\n","import React from \"react\";\n\ninterface IProps {\n  text: string;\n  onClick: () => void;\n}\nconst Button = ({ text, onClick }: IProps) => {\n  return (\n    <button className={`mini`} onClick={onClick}>\n      {text}\n    </button>\n  );\n};\n\nexport default Button;\n","import React from \"react\";\nimport PianoKyes from \"Containers/PianoKyes\";\nimport { Utils } from \"Core/Utils\";\nimport * as Tone from \"tone\";\nimport Button from \"Components/Button\";\n\nconst synth = new Tone.Synth().toDestination();\n\nfunction App() {\n  const handleScale = () => {\n    const list = Utils.getScale5(\"C3\");\n    const now = Tone.now();\n    list.forEach((v, i) => synth.triggerAttackRelease(v, \"8n\", now + i * 0.5));\n  };\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <PianoKyes />\n        <Button text=\"화음\" onClick={handleScale} />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { Utils } from \"Core/Utils\";\nimport { IToneKeyboard } from \"Interface/IToneKeyboard\";\nimport { PianoActions, PIANO_RELEASE, PIANO_TRIGGER } from \"./actions\";\n\ninterface IState {\n  tones: IToneKeyboard[];\n}\n\nconst temp = Utils.initTones(3, 4);\nconst initState: IState = {\n  tones: temp,\n};\n\nconst pianoReducer = (state: IState = initState, actions: PianoActions) => {\n  switch (actions.type) {\n    case PIANO_TRIGGER:\n      const tone = actions.payload;\n      const index = state.tones.findIndex((v) => v.tone === tone);\n      const newTones = [...state.tones];\n      newTones[index].isValue = true;\n      return {\n        ...state,\n        tones: [...newTones],\n      };\n    case PIANO_RELEASE: {\n      const tone = actions.payload;\n      const index = state.tones.findIndex((v) => v.tone === tone);\n      const newTones = [...state.tones];\n      newTones[index].isValue = false;\n      return {\n        ...state,\n        tones: [...newTones],\n      };\n    }\n    default:\n      return state;\n  }\n};\n\nexport default pianoReducer;\n","import pianoReducer from \"Core/piano/reducer\";\nimport { createStore, combineReducers, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nconst rootReducer = combineReducers({ piano: pianoReducer });\nlet store: any;\n\n// 추후 디버거 생성\nstore = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\nexport type RootState = ReturnType<typeof rootReducer>;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"App/App\";\nimport \"styles/index.scss\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { Provider } from \"react-redux\";\nimport store from \"Core/Store\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}